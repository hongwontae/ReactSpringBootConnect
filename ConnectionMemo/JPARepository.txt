spring.jpa.hibernate.ddl-auto

create: 기존테이블 삭제 후 다시 생성 + 닫을 때 삭제하지 않는다.
create-drop: create와 같으나 종료시점에 테이블 DROP
update: 하이버네이트는 주어진 엔티티 구조에 따라서 데이터베이스를 변경한다.
validate: 엔티티와 테이블이 정상 매핑되었는지만 확인
none: 어떠한 변화도 주지 않는다.mysql에서 default이다.


@MappedSuperclass
객체의 입장에서 공통 매핑 정보가 필요할 때 사용한다.
공통 매핑 정보가 필요할 때, 부모 클래스에 선언하고 속성만 상속 받아서 사용하고 싶을 때
 @MappedSuperclass를 사용한다.
DB 테이블과는 상관없다. 아래에 보면 DB는 매핑 정보 다 따로 쓰고 있다. 객체의 입장이다.
상속광계 매핑이 아니다.


@MappedSuperclass가 선언되어 있는 클래스는 엔티티가 아니다. 당연히 테이블과 매핑도 안된다.
단순히 부모 클래스를 상속 받는 자식 클래스에 매핑 정보만 제공한다.
조회, 검색이 불가하다. 부모 타입으로 조회하는 것이 불가능하다는 이야기.(em.find(BaseEntity) 불가능)
직접 생성해서 사용할 일이 없으므로 추상 클래스로 만드는 것을 권장한다.
테이블과 관계가 없고, 단순히 엔티티가 공통으로 사용하는 매핑 정보를 모으는 역할을 한다.
주로 등록일, 수정일, 등록자, 수정자 같은 전체 엔티티에서 공통으로 적용하는 정보를 모을 때 사용한다.

참고
JPA에서 @Entity 클래스는 @Entity나 @MappedSuperclass로 지정한 클래스만 상속할 수 있다.


@Entity?
데이터 베이스에 대응하는 하나의 클래스라고 생각하면 된다. 이 어노테이션을 사용하면 테이블+엔티티가 만들어지는 것이다.
@Entity가 붙은 클래스는 JPA가 관리해주며, JPA를 사용해서 DB 테이블과 매핑할 클래스는 @Entity를 꼭 붙여야만 매핑이 가능합니다.

@Entity(name = "Member") 엔티티에만 이름을 부여할 수 있다.

JPA는 JPQL이라는 SQL을 추상화한 객체지향 쿼리 언어를 지원합니다. JPQL은 테이블이 아닌 엔티티를 대상으로 쿼리를 수행하는데, 이때 이 쿼리에 엔티티의 이름이 사용됩니다.


@Table?
엔티티와 매핑할 테이블을 지정합니다. name속성있다. table 이름 정해주는 것이다.


@Column?
@Column은 객체 필드를 테이블의 컬럼에 매핑시켜주는 어노테이션입니다.

속성 
1. updateable 엔티티 수정 시 이 필드도 같이 수정한다.
false로 설정하면 데이터베이스에 수정하지 않는다.
false 옵션은 읽기 전용일 때 사용한다

2. nullable (DDL) DDL 생성 시 null 값의 허용 여부를 설정한다.
false로 설정하면 not null 제약조건이 붙는다.

3.length (DDL) 문자 길이 제약조건, String 타입에만 사용한다. 기본값은 255


Repository?
jpa레파지토리는 인터페이스이고 엔티티의 데이터를 관리한다.
jpaRepository<1,2>
1 => 엔티티클래스이름
2 => 필드타입은 래퍼클래스로 해야된다.

crud하는 기본적인 쿼리를 작동시키는 메서드가 존재한다. 
but 어려운 쿼리문은 지원하지 못한다.
그래서 메서드에 @Query를 붙이면 쿼리를 직접 작성할 수 있는데 이는 기본적인 문법이 아니라 jpql문법의 sql이 작동된다. nativeQuery를 true로 설정하면 nativeQuery를 작성할 수 있는데 왠만하면 작성하지 않는다.
=> 항상 기억해야 될 것은 entity의 데이터에 대한 쿼리를 작성한다는 것이다.

★ Entity의 영속성
jpa는 내부적으로 데이터를 담기위한 공간을 가진다. 이를 transactional로 관리한다. 데이터가 commit or rollback전까지 변경상태가 유지된다.
무엇이 영속적? => 쿼리문을 날려 post entity의 pk id의 1를 가져왔다. 근데 똑같이 1을 가져오면 쿼리를 다시 날리는 게 아니라 메모리에 있는 기존의 1를 준다.
데이터베이스에 저장하는 함수 save, saveAndFlush의 차이를 살펴보자
saveAndFlush함수는 저장 즉시 데이터를 데이터베이스로 전송하고 
svae 함수는 @Transactional 범위가 종료되면 commit이 되는 순간 데이터베이스에 저장이 된다.
























